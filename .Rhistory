devtools::install_github("openwashdata/washr")
clear
remove.packages("washr")
library(washr)
devtools::install_github("openwashdata/washr")
library(washr)
setup_rawdata()
# Description ------------------------------------------------------------------
# R script to process uploaded raw data into a tidy, analysis-ready data frame
# Load packages ----------------------------------------------------------------
## Run the following code in console if you don't have the packages
## install.packages(c("usethis", "fs", "here", "readr", "readxl", "openxlsx"))
library(usethis)
library(fs)
library(here)
library(readr)
library(dplyr)
library(readxl)
library(openxlsx)
library(lubridate)
library(ggplot2)
library(maps)
# Load Data --------------------------------------------------------------------
# Load the necessary data from a CSV file
data_in <- readr::read_csv("data-raw/borrehole lab chemistry.csv")
# (Optional) Read and clean the codebook if needed (commented out for now)
# codebook <- readxl::read_excel("data-raw/codebook.xlsx") %>%
#   clean_names()
# Tidy data --------------------------------------------------------------------
# Remove rows where the 'latitude' column contains NULL (NA) values
data_in <- data_in %>%
filter(!is.na(latitude))
# Function to check for non-UTF-8 characters in character columns
check_utf8 <- function(df) {
# Identify columns with invalid UTF-8 characters
invalid_cols <- sapply(df, function(column) {
if (!is.character(column)) return(FALSE) # Skip non-character columns
any(sapply(column, function(x) {
if (is.na(x)) return(FALSE) # Ignore NA values
!identical(iconv(x, from = "UTF-8", to = "UTF-8"), x)
}))
})
# Extract the column names with invalid characters
bad_cols <- names(df)[invalid_cols]
# Output a message depending on whether non-UTF-8 characters were found
if (length(bad_cols) > 0) {
message("Non-UTF-8 characters detected in columns: ",
paste(bad_cols, collapse = ", "))
} else {
message("No non-UTF-8 characters found.")
}
}
# Convert character columns from Latin1 encoding to UTF-8, removing problematic
#   characters
data_in[] <- lapply(data_in, function(x) {
if (is.character(x)) {
# Convert to UTF-8 and remove problematic characters
iconv(x, from = "latin1", to = "UTF-8", sub = "")
} else {
x
}
})
# Re-check the data for non-UTF-8 characters after the conversion
check_utf8(data_in)
boreholelabdata <- data_in
# Export Data ------------------------------------------------------------------
usethis::use_data(boreholelabdata, overwrite = TRUE)
fs::dir_create(here::here("inst", "extdata"))
readr::write_csv(boreholelabdata,
here::here("inst", "extdata", paste0("boreholelabdata", ".csv")))
openxlsx::write.xlsx(boreholelabdata,
here::here("inst", "extdata", paste0("boreholelabdata",
".xlsx")))
setup_dictionary()
library(washr)
setup_dictionary()
setup_roxygen()
devtools::document()
devtools::check()
devtools::install()
use_author(
given = "Emmanuel",
family = "Mhango",
role = c("aut", "cre"),
email = "emmanuellmhango@gmail.com",
comment = c(ORCID = "0000-0003-3197-6244")
)
use_author(given = "Finlay", family = "Paterson", role = c("aut","ctb"))
use_author(given = "Jamie", family = "Rattray", role = c("aut","ctb"))
update_description()
devtools::document()
devtools::check()
devtools::install()
add_metadata()
update_metadata()
generate_jsonld()
devtools::document()
devtools::check()
devtools::install()
setup_readme()
#========================================
# Load required libraries
library(tidyverse)
library(lubridate)
# Use your existing dataset
df <- boreholelabdata
# Convert sample collection date to Date format
df$date_sample_collected <- as.Date(df$date_sample_collected)
# Extract the month for grouping (rounded to first day of month)
df$month <- floor_date(df$date_sample_collected, "month")
# Reshape to long format for selected parameters
df_long <- df %>%
select(month,
tds_mg_l,
fluoride_mg_l,
nitrate_mg_l) %>%
pivot_longer(cols = -month, names_to = "parameter", values_to = "value") %>%
drop_na()
# ---- Boxplot by Month ----
ggplot(df_long, aes(x = month, y = value, fill = parameter)) +
geom_boxplot(outlier.color = "red", alpha = 0.6) +
facet_wrap(~ parameter, scales = "free_y") +
labs(title = "Distribution of Water Quality Parameters Over Time",
x = "Month",
y = "Concentration (mg/L)",
fill = "Parameter") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# ---- Line Plot of Monthly Median Trends ----
df_median <- df_long %>%
group_by(month, parameter) %>%
summarize(median_value = median(value, na.rm = TRUE), .groups = "drop")
ggplot(df_median, aes(x = month, y = median_value, color = parameter)) +
geom_line(size = 1.2) +
geom_point(size = 2) +
labs(title = "Median Trends of Water Quality Parameters",
x = "Month",
y = "Median Concentration (mg/L)",
color = "Parameter") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# ---- Boxplot by Month ----
ggplot(df_long, aes(x = month, y = value, fill = parameter)) +
geom_boxplot(outlier.color = "red", alpha = 0.6) +
facet_wrap(~ parameter, scales = "free_y") +
labs(title = "Distribution of Water Quality Parameters Over Time",
x = "Month",
y = "Concentration (mg/L)",
fill = "Parameter") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
install.packages("leaflet")
#========================================
# Load libraries
library(leaflet)
library(dplyr)
# Use your dataset
df <- boreholelabdata
# Filter rows that have coordinates and fluoride status
df_map <- df %>%
filter(!is.na(latitude) & !is.na(longitude) & !is.na(fluoride_within_standards)) %>%
mutate(status_color = case_when(
fluoride_within_standards == "Yes" ~ "green",
fluoride_within_standards == "No" ~ "red",
TRUE ~ "gray"
))
# Create popup label
df_map$popup <- paste0(
"<b>Waterpoint:</b> ", df_map$waterpoint_name, "<br>",
"<b>Fluoride (mg/L):</b> ", df_map$fluoride_mg_l, "<br>",
"<b>Within Standards:</b> ", df_map$fluoride_within_standards
)
# Generate the interactive map
leaflet(df_map) %>%
addTiles() %>%
addCircleMarkers(
lng = ~longitude,
lat = ~latitude,
radius = 6,
color = ~status_color,
stroke = TRUE,
fillOpacity = 0.8,
popup = ~popup
) %>%
addLegend(
position = "bottomright",
colors = c("green", "red", "gray"),
labels = c("Within Standards", "Outside Standards", "Unknown"),
title = "Fluoride Quality"
)
#========================================
# Load required libraries
# Load required libraries
library(leaflet)
library(dplyr)
# Use your data
df <- boreholelabdata
# Filter for points with coordinates and fluoride compliance data
df_map <- df %>%
filter(!is.na(latitude), !is.na(longitude), !is.na(fluoride_within_standards)) %>%
mutate(status_color = case_when(
fluoride_within_standards == "Yes" ~ "green",
fluoride_within_standards == "No" ~ "red",
TRUE ~ "gray"
))
# Create popup label
df_map$popup <- paste0(
"<b>Waterpoint:</b> ", df_map$waterpoint_name, "<br>",
"<b>Fluoride (mg/L):</b> ", df_map$fluoride_mg_l, "<br>",
"<b>Within Standards?:</b> ", df_map$fluoride_within_standards
)
# Create the interactive map
leaflet(df_map) %>%
addTiles() %>%
addCircleMarkers(
lng = ~longitude,
lat = ~latitude,
radius = 6,
color = ~status_color,
stroke = TRUE,
fillOpacity = 0.8,
popup = ~popup
) %>%
addLegend(
position = "bottomright",
colors = c("green", "red", "gray"),
labels = c("Within Standards", "Outside Standards", "Unknown"),
title = "Fluoride Compliance"
)
#========================================
# Load required libraries
library(map)     # Your custom or wrapper map library
library(maps)
#========================================
# Load required libraries
library(maps)     # Your custom or wrapper map library
library(leaflet)
library(dplyr)
# Use your data frame
df <- boreholelabdata
# Filter valid coordinates and fluoride status
df_map <- df %>%
filter(!is.na(latitude), !is.na(longitude), !is.na(fluoride_within_standards)) %>%
mutate(status_color = case_when(
fluoride_within_standards == "Yes" ~ "green",
fluoride_within_standards == "No" ~ "red",
TRUE ~ "gray"
))
# Create popup label
df_map$popup <- paste0(
"<b>Waterpoint:</b> ", df_map$waterpoint_name, "<br>",
"<b>Fluoride (mg/L):</b> ", df_map$fluoride_mg_l, "<br>",
"<b>Within Standards?:</b> ", df_map$fluoride_within_standards
)
# Generate the interactive Leaflet map, focused on Malawi
leaflet(df_map) %>%
addTiles() %>%
setView(lng = 34.3, lat = -13.5, zoom = 6.5) %>%  # Center on Malawi
addCircleMarkers(
lng = ~longitude,
lat = ~latitude,
radius = 6,
color = ~status_color,
stroke = TRUE,
fillOpacity = 0.8,
popup = ~popup
) %>%
addLegend(
position = "bottomright",
colors = c("green", "red", "gray"),
labels = c("Within Standards", "Outside Standards", "Unknown"),
title = "Fluoride Compliance"
)
#========================================
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
# Use your dataset
df <- boreholelabdata
# Select relevant compliance columns and reshape to long format
compliance_long <- df %>%
select(fluoride_within_standards,
nitrate_within_standards,
ph_within_mw_standards) %>%
pivot_longer(cols = everything(),
names_to = "parameter",
values_to = "compliance") %>%
filter(!is.na(compliance)) %>%
mutate(parameter = case_when(
parameter == "fluoride_within_standards" ~ "Fluoride",
parameter == "nitrate_within_standards" ~ "Nitrate",
parameter == "ph_within_mw_standards" ~ "pH",
TRUE ~ parameter
))
# Count compliance status by parameter
compliance_summary <- compliance_long %>%
group_by(parameter, compliance) %>%
summarise(count = n(), .groups = "drop")
# Plot stacked bar chart
ggplot(compliance_summary, aes(x = parameter, y = count, fill = compliance)) +
geom_bar(stat = "identity") +
scale_fill_manual(values = c("Yes" = "green", "No" = "red")) +
labs(
title = "Water Quality Compliance Summary",
x = "Parameter",
y = "Number of Samples",
fill = "Within Standards"
) +
theme_minimal()
#========================================
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
# Select relevant compliance columns and reshape to long format
compliance_long <- boreholelabdata %>%
select(fluoride_within_standards,
nitrate_within_standards,
ph_within_mw_standards) %>%
pivot_longer(cols = everything(),
names_to = "parameter",
values_to = "compliance") %>%
filter(!is.na(compliance)) %>%
mutate(parameter = case_when(
parameter == "fluoride_within_standards" ~ "Fluoride",
parameter == "nitrate_within_standards" ~ "Nitrate",
parameter == "ph_within_mw_standards" ~ "pH",
TRUE ~ parameter
))
# Count compliance status by parameter
compliance_summary <- compliance_long %>%
group_by(parameter, compliance) %>%
summarise(count = n(), .groups = "drop")
# Plot stacked bar chart
ggplot(compliance_summary, aes(x = parameter, y = count, fill = compliance)) +
geom_bar(stat = "identity") +
scale_fill_manual(values = c("Yes" = "green", "No" = "red")) +
labs(
title = "Water Quality Compliance Summary",
x = "Parameter",
y = "Number of Samples",
fill = "Within Standards"
) +
theme_minimal()
devtools::build_readme()
devtools::build_readme()
setup_website()
library(washr)
setup_website()
devtools::document()
devtools::check()
devtools::install()
# Description ------------------------------------------------------------------
# R script to process uploaded raw data into a tidy, analysis-ready data frame
# Load packages ----------------------------------------------------------------
## Run the following code in console if you don't have the packages
## install.packages(c("usethis", "fs", "here", "readr", "readxl", "openxlsx"))
library(usethis)
library(fs)
library(here)
library(readr)
library(dplyr)
library(readxl)
library(openxlsx)
library(lubridate)
library(ggplot2)
library(maps)
# Load Data --------------------------------------------------------------------
# Load the necessary data from a CSV file
data_in <- readr::read_csv("data-raw/borrehole lab chemistry.csv")
# (Optional) Read and clean the codebook if needed (commented out for now)
# codebook <- readxl::read_excel("data-raw/codebook.xlsx") %>%
#   clean_names()
# Tidy data --------------------------------------------------------------------
# Remove rows where the 'latitude' column contains NULL (NA) values
data_in <- data_in %>%
filter(!is.na(latitude))
# Function to check for non-UTF-8 characters in character columns
check_utf8 <- function(df) {
# Identify columns with invalid UTF-8 characters
invalid_cols <- sapply(df, function(column) {
if (!is.character(column)) return(FALSE) # Skip non-character columns
any(sapply(column, function(x) {
if (is.na(x)) return(FALSE) # Ignore NA values
!identical(iconv(x, from = "UTF-8", to = "UTF-8"), x)
}))
})
# Extract the column names with invalid characters
bad_cols <- names(df)[invalid_cols]
# Output a message depending on whether non-UTF-8 characters were found
if (length(bad_cols) > 0) {
message("Non-UTF-8 characters detected in columns: ",
paste(bad_cols, collapse = ", "))
} else {
message("No non-UTF-8 characters found.")
}
}
# Convert character columns from Latin1 encoding to UTF-8, removing problematic
#   characters
data_in[] <- lapply(data_in, function(x) {
if (is.character(x)) {
# Convert to UTF-8 and remove problematic characters
iconv(x, from = "latin1", to = "UTF-8", sub = "")
} else {
x
}
})
# Re-check the data for non-UTF-8 characters after the conversion
check_utf8(data_in)
boreholelabdata <- data_in
# Export Data ------------------------------------------------------------------
usethis::use_data(boreholelabdata, overwrite = TRUE)
fs::dir_create(here::here("inst", "extdata"))
readr::write_csv(boreholelabdata,
here::here("inst", "extdata", paste0("boreholelabdata", ".csv")))
openxlsx::write.xlsx(boreholelabdata,
here::here("inst", "extdata", paste0("boreholelabdata",
".xlsx")))
library(washr)
devtools::build_readme()
devtools::build_readme()
devtools::document()
devtools::check()
devtools::install()
setup_website()
setup_website()
devtools::document()
devtools::check()
devtools::install()
